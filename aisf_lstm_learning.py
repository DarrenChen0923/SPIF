# -*- coding: utf-8 -*-
"""AISF_LSTM Learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nSjk4ymP1xodFSg_VTtDdA4j_O4CBaas

<b> The output of this notebook is a txt file contains center point cordinate in each grid, as well as the error result

## Improt lib
"""

import pandas as pd
import numpy as np
from matplotlib import cm
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.colors
# %matplotlib inline

import math
import matplotlib.cm as cmx
# %matplotlib notebook
from scipy.linalg import solve
# import h5py
# from pyntcloud import PyntCloud
from mpl_toolkits import mplot3d
import statsmodels.api as sm 
from sklearn import datasets, linear_model

"""## Load files and change all point corrdinates to numerical
## need to edit your own google drive path to reach this files
"""

# Parameters 
cad_fileName = "./fin_reg.txt"  #change to your own path
realsheet_fileName = "./f1out_python.txt" #change to your own path
size_of_grid  = 2

gin = pd.read_csv(cad_fileName)
gout = pd.read_csv(realsheet_fileName)
# grid = pd.read_csv('grid_file.csv')
# f=h5py.File("file1.hdf5","a")
gout = gout.apply(pd.to_numeric, errors='ignore')
gin =gin.apply(pd.to_numeric, errors='ignore')

"""## visualize point cloud"""

# plt.plot(gin['x'],gin['y'], marker='.',markersize=0.01, color='red', linestyle='none')
# plt.gca().set_aspect('equal') #set same ratio for x and y axis
# plt.show()

# plt.plot(gout['x'],gout['y'], marker='.',markersize=0.01, color='red', linestyle='none')
# plt.gca().set_aspect('equal') #set same ratio for x and y axis
# plt.show()

"""## Find the edge of whole point cloud (no need to run for now)"""

# print("gout:","min_x",gout["x"].min(),", max_x",gout["x"].max(),",","min_y",gout["y"].min(),", max_y",gout["y"].max(),"min_z",gout["z"].min(),"max_z",gout["z"].max())

# print("gin:","min_x",gin["x"].min(),", max_x",gin["x"].max(),",","min_y",gin["y"].min(),", max_y",gin["y"].max(),",z_min",gin["z"].min(),"max_z",gin["z"].max())

# # dom = gin.sort_values(by='y', ascending=False)
# # dom
# # dom[dom['x'] == 170].sort_values(by = 'y')
# # dom = gin.sort_values(by='y', ascending=True)
# # dom['y'].max()

# x_ran = np.array([-90,110,-100,130,-170,-170,170,170])
# y_ran = np.array([-170,-170,170,170,-90,100,-110,130])
# plt.plot(x_ran,y_ran,"o")
# plt.title("Gin edge points")
# plt.axhline(y=0, color='r')
# plt.axhline(y=170, color='b')
# plt.axhline(y=-170, color='b')
# plt.axvline(x=170, color='b')
# plt.axvline(x=-170, color='b')
# plt.axvline(x=0, color='r')
# plt.show()
# # Gin
# #固定y = -170 x最大和最小value
# # -90.000000,-170.0
# # 110.000000,-170.0

# #固定y = 170 x最大和最小value
# #-100.000000,170.0
# # 130.000000,170.0

# #固定x = -170 y最大和最小value
# # -170.0,-90.000000
# # -170.0,100.000000

# #固定x = 170 y最大和最小value
# #170.0,-110.000000
# #170.0,130.000000

"""## set *d (mm)* the length of side of grid and create grid"""

d = size_of_grid 
# mm in this case

#use gin to generate grid
x_axis = np.arange(gin["x"].min(),gin["x"].max(),d)
y_axis = np.arange(gin["y"].min(),gin["y"].max(),d)
X,Y = np.meshgrid(x_axis,y_axis)

"""## calculate error

### get plane function of each grid
must contain at least 3 point in each area for ols to find a plane function for both gin and gout

fraction equation
<br>
$\frac{x  -  cin[0]}{norm_in[0]} = \frac{y - cin[1]}{norm_in[1]} = \frac{z - cin[2]}{norm_in[2]}$
<br><br>
plane_gout_equation<br>
$ z = norm__out[0]*x + norm__out[1]*y + intersect__out $
"""

def getplane_ols(x_list, y_list, z_list):
    if len(x_list) < 3: 
#         print("normvectnull")
#         print()
        return [], []
    else: 
        X1=np.column_stack((x_list,y_list))
        X1=sm.add_constant(X1)
        model = sm.OLS(z_list, X1)
        result = model.fit()
#         print("para:",result.params)
        norm_vector = [result.params[1],result.params[2],-1]
        intersect = result.params[0]
#         print('normvect', norm_vector)
#         print()
        return norm_vector, intersect

"""### get intersection point
normal vector form gin center to gout plane function 
"""

def solve_for_intersection(norm_in, norm_out, cin, cout, intersect_out):
    if len(norm_in) == 3 and len(norm_out) == 3:
#         print(norm_in, norm_out, cin, cout, intersect_out)
        lhs = np.array([[norm_in[1]/norm_in[0],-1,0],[0,-1,norm_in[1]/norm_in[2]],[norm_out[0],norm_out[1],-1]])
        rhs = np.array([[((norm_in[1]*cin[0])/norm_in[0]) - cin[1]],
                        [((cin[2]*norm_in[1])/norm_in[2]) - cin[1]],
                        [-intersect_out]])
        try:
            result = solve(lhs,rhs)
            # print("intersect point cordinates: ", result)
            if result[2] - cin[2] >= 0:
                error = math.sqrt((result[0] - cin[0])**2 + (result[1] - cin[1])**2 + (result[2] - cin[2])**2)
            else:
                error = -math.sqrt((result[0] - cin[0])**2 + (result[1] - cin[1])**2 + (result[2] - cin[2])**2)
            
#             print("error:" , error)
#             print()
            return error, result
        
        except:
#             print('array must not contain infs or NaNs')
#             print()
            return np.nan, np.nan
        
    else:
#         print("error: ")
#         print()
        return np.nan, np.nan

"""### Create txt file to record error no need to run for now
center point cordinates of gin and error associate with it
structure: <br> 
$ center_x , center_y , center_z, error $

"""

"""this block are code that write file in txt no need to run for now""" 

# # f_error.close()
# f_error = open("error.txt", "w")
# f_error.write('center_x,'+'center_y,'+'center_z,'+'error'+"\n")
# f_error

"""## calculate error and write in error txt file """

# 左下xy，右下xy，左上xy，右上点xy, 中点xy
pd.options.mode.chained_assignment = None
grid_cordinate = [list(i) for i in zip(X.flat, Y.flat,
                                 (X+d).flat, Y.flat,
                                 X.flat, (Y+d).flat,
                                (X+d).flat, (Y+d).flat,
                                 (X+d/2).flat, (Y+d/2).flat)]
idx = 0
for grid in grid_cordinate:
    
    #seperate and group points in each grid area
    gout_grid = gout[(gout['x'] >= grid[0]) & (gout['x'] < grid[2]) & (gout['y'] >= grid[1]) & (gout['y']< grid[5])]
    gin_grid = gin[(gin['x'] >= grid[0]) & (gin['x'] < grid[2]) & (gin['y'] >= grid[1]) & (gin['y']< grid[5])]
    
    
    #embed grid index to each point
    gout_grid["grid_idx"] = idx 
    gin_grid["grid_idx"] = idx
    
#   print(gout_grid['x'])
    #center point cordinates xyz
    gout_center_xyz = [grid[8],grid[9],gout_grid["z"].mean()]
    gin_center_xyz = [grid[8],grid[9],gin_grid["z"].mean()]
    
    #拟合平面得到normal vector
    plane_gout_norm, b0_out = getplane_ols(list(gout_grid['x']),list(gout_grid['y']),list(gout_grid['z']))
    plane_gin_norm, b0_in = getplane_ols(list(gin_grid['x']),list(gin_grid['y']),list(gin_grid['z']))
    
    #solve the intersection point and calculate error
    solu, intersect_pt = solve_for_intersection(plane_gin_norm,plane_gout_norm,gin_center_xyz,gout_center_xyz, b0_out)
    
    if abs(solu) >= 10:
      print("gout point:",gout_grid)
      print("gin point:",gin_grid)
      print("plane_gout_norm vector:",plane_gout_norm)
      print("plane_gin_norm vector:", plane_gin_norm)
      print("intersect_pt:" , intersect_pt)
      print("error result:", solu)
      print("end")
      print("-----------")
      print()
      print()
    else:
      pass




    """below are code that write file in txt no need to run for now""" 
    # f_error.write(str(gin_center_xyz[0]) +','+ str(gin_center_xyz[1])+',' + str(gin_center_xyz[2]) +','+ str(solu) + '\n')
    
    idx += 1

